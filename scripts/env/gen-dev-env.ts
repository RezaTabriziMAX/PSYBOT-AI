/* eslint-disable no-console */
/**
 * Nuttoo dev env generator
 *
 * Purpose:
 * - Generate a local development `.env` file for the Nuttoo monorepo
 * - Merge defaults + safe computed values + optional overrides
 * - Avoid overwriting existing values unless explicitly requested
 *
 * Usage:
 *   pnpm ts-node scripts/env/gen-dev-env.ts
 *   node --loader ts-node/esm scripts/env/gen-dev-env.ts
 *
 * Arguments:
 *   --out <path>          Output file (default: .env)
 *   --force               Overwrite existing output file completely
 *   --merge               Merge with existing output file (default behavior)
 *   --set KEY=VALUE       Apply overrides (can be repeated)
 *   --print               Print resulting env to stdout (still writes unless --dry-run)
 *   --dry-run             Do not write, only print
 *   --no-secrets          Do not generate placeholder secrets (leave blank)
 *
 * Notes:
 * - This file is intended to be committed in `scripts/`, not generated output.
 * - Generated `.env` should not be committed.
 */

import fs from "node:fs";
import path from "node:path";
import os from "node:os";
import crypto from "node:crypto";

type KV = Record<string, string>;

type Args = {
  outPath: string;
  force: boolean;
  merge: boolean;
  print: boolean;
  dryRun: boolean;
  noSecrets: boolean;
  overrides: KV;
};

function die(msg: string): never {
  console.error(`[gen-dev-env] error: ${msg}`);
  process.exit(1);
}

function log(msg: string): void {
  console.log(`[gen-dev-env] ${msg}`);
}

function randomSecret(bytes = 32): string {
  return crypto.randomBytes(bytes).toString("hex");
}

function parseArgs(argv: string[]): Args {
  const args: Args = {
    outPath: ".env",
    force: false,
    merge: true,
    print: false,
    dryRun: false,
    noSecrets: false,
    overrides: {}
  };

  for (let i = 0; i < argv.length; i++) {
    const a = argv[i] ?? "";
    if (a === "--out") {
      const v = argv[++i];
      if (!v) die("Missing value for --out");
      args.outPath = v;
      continue;
    }
    if (a === "--force") {
      args.force = true;
      args.merge = false;
      continue;
    }
    if (a === "--merge") {
      args.merge = true;
      args.force = false;
      continue;
    }
    if (a === "--print") {
      args.print = true;
      continue;
    }
    if (a === "--dry-run") {
      args.dryRun = true;
      continue;
    }
    if (a === "--no-secrets") {
      args.noSecrets = true;
      continue;
    }
    if (a === "--set") {
      const kv = argv[++i];
      if (!kv) die("Missing value for --set KEY=VALUE");
      const idx = kv.indexOf("=");
      if (idx <= 0) die(`Invalid --set format: ${kv}`);
      const key = kv.slice(0, idx).trim();
      const value = kv.slice(idx + 1).trim();
      if (!key) die(`Invalid --set key: ${kv}`);
      args.overrides[key] = value;
      continue;
    }

    // Allow bare KEY=VALUE for convenience
    if (a.includes("=") && !a.startsWith("--")) {
      const idx = a.indexOf("=");
      const key = a.slice(0, idx).trim();
      const value = a.slice(idx + 1).trim();
      if (key) args.overrides[key] = value;
      continue;
    }

    die(`Unknown argument: ${a}`);
  }

  return args;
}

function parseEnvFile(content: string): KV {
  const out: KV = {};
  const lines = content.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    if (trimmed.startsWith("#")) continue;

    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;

    const key = trimmed.slice(0, eq).trim();
    let value = trimmed.slice(eq + 1);

    // Strip surrounding quotes if present
    value = value.trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    if (key) out[key] = value;
  }

  return out;
}

function serializeEnvFile(kv: KV): string {
  // Stable order: group common keys first, then alphabetize the rest.
  const preferredOrder = [
    "NODE_ENV",
    "NUTTOO_NAME",
    "NUTTOO_TICKER",
    "NUTTOO_API_PORT",
    "NUTTOO_WEB_PORT",
    "VITE_API_BASE_URL",
    "CORS_ORIGIN",
    "DATABASE_URL",
    "REDIS_URL",
    "JWT_SECRET",
    "API_KEY_SALT",
    "LOG_LEVEL"
  ];

  const keys = Object.keys(kv);
  const preferred = preferredOrder.filter((k) => keys.includes(k));
  const remaining = keys
    .filter((k) => !preferred.includes(k))
    .sort((a, b) => a.localeCompare(b));

  const ordered = [...preferred, ...remaining];

  const header = [
    "# Auto-generated by scripts/env/gen-dev-env.ts",
    "# Safe to edit locally. Do not commit this file.",
    `# Generated at: ${new Date().toISOString()}`,
    ""
  ].join("\n");

  const body = ordered
    .map((k) => {
      const v = kv[k] ?? "";
      // Quote only when needed
      const needsQuotes = /[\s#]/.test(v) || v.includes('"');
      if (!needsQuotes) return `${k}=${v}`;
      const escaped = v.replace(/"/g, '\\"');
      return `${k}="${escaped}"`;
    })
    .join("\n");

  return `${header}${body}\n`;
}

function findRepoRoot(startDir: string): string {
  let dir = path.resolve(startDir);
  for (let i = 0; i < 12; i++) {
    const ws = path.join(dir, "pnpm-workspace.yaml");
    const pkg = path.join(dir, "package.json");
    if (fs.existsSync(ws) && fs.existsSync(pkg)) return dir;
    const parent = path.dirname(dir);
    if (parent === dir) break;
    dir = parent;
  }
  return path.resolve(startDir);
}

function buildDefaults(repoRoot: string): KV {
  const apiPort = "8787";
  const webPort = "5173";

  // Use localhost by default; docker-compose will override for container networking.
  const dbUrl = "postgresql://nuttoo:nuttoo@localhost:5432/nuttoo";
  const redisUrl = "redis://localhost:6379";

  const defaults: KV = {
    NODE_ENV: "development",
    NUTTOO_NAME: "Nuttoo",
    NUTTOO_TICKER: "NUTTOO",
    NUTTOO_API_PORT: apiPort,
    NUTTOO_WEB_PORT: webPort,
    VITE_API_BASE_URL: `http://localhost:${apiPort}`,
    CORS_ORIGIN: `http://localhost:${webPort}`,
    DATABASE_URL: dbUrl,
    REDIS_URL: redisUrl,
    LOG_LEVEL: "info",

    // Repository-aware paths (optional; useful for workers later)
    NUTTOO_REPO_ROOT: repoRoot,
    NUTTOO_STORAGE_DIR: path.join(repoRoot, "storage", "local")
  };

  return defaults;
}

function applySecrets(kv: KV, noSecrets: boolean): KV {
  if (noSecrets) {
    // Ensure keys exist but are empty to signal "user must set"
    return {
      ...kv,
      JWT_SECRET: kv.JWT_SECRET ?? "",
      API_KEY_SALT: kv.API_KEY_SALT ?? ""
    };
  }

  const withSecrets = { ...kv };
  if (!withSecrets.JWT_SECRET) withSecrets.JWT_SECRET = randomSecret(32);
  if (!withSecrets.API_KEY_SALT) withSecrets.API_KEY_SALT = randomSecret(16);
  return withSecrets;
}

function mergeEnv(base: KV, incoming: KV): KV {
  // Incoming has priority; used when merging existing env into defaults.
  return { ...base, ...incoming };
}

function main(): void {
  const args = parseArgs(process.argv.slice(2));

  const cwd = process.cwd();
  const repoRoot = findRepoRoot(cwd);
  const absOut = path.isAbsolute(args.outPath)
    ? args.outPath
    : path.join(repoRoot, args.outPath);

  log(`repoRoot=${repoRoot}`);
  log(`out=${absOut}`);

  const defaults = buildDefaults(repoRoot);

  let existing: KV = {};
  if (fs.existsSync(absOut) && args.merge) {
    const raw = fs.readFileSync(absOut, "utf8");
    existing = parseEnvFile(raw);
    log(`found existing env with ${Object.keys(existing).length} keys`);
  } else if (fs.existsSync(absOut) && args.force) {
    log("force overwrite enabled");
  } else if (fs.existsSync(absOut) && !args.merge && !args.force) {
    log("output exists; default behavior is merge. Use --force to overwrite.");
  }

  // Build final map:
  // defaults -> existing (if merge) -> secrets -> overrides
  let finalEnv = defaults;

  if (args.merge) {
    finalEnv = mergeEnv(finalEnv, existing);
  }

  finalEnv = applySecrets(finalEnv, args.noSecrets);

  // Apply override map last
  finalEnv = mergeEnv(finalEnv, args.overrides);

  // Ensure VITE_API_BASE_URL and CORS_ORIGIN reflect ports if user updated ports
  const apiPort = finalEnv.NUTTOO_API_PORT || defaults.NUTTOO_API_PORT;
  const webPort = finalEnv.NUTTOO_WEB_PORT || defaults.NUTTOO_WEB_PORT;

  if (!("VITE_API_BASE_URL" in args.overrides) && !("VITE_API_BASE_URL" in existing)) {
    finalEnv.VITE_API_BASE_URL = `http://localhost:${apiPort}`;
  }
  if (!("CORS_ORIGIN" in args.overrides) && !("CORS_ORIGIN" in existing)) {
    finalEnv.CORS_ORIGIN = `http://localhost:${webPort}`;
  }

  // Persist a helpful local marker
  finalEnv.NUTTOO_MACHINE = finalEnv.NUTTOO_MACHINE || os.hostname();

  const output = serializeEnvFile(finalEnv);

  if (args.print || args.dryRun) {
    console.log(output);
  }

  if (!args.dryRun) {
    fs.mkdirSync(path.dirname(absOut), { recursive: true });
    fs.writeFileSync(absOut, output, "utf8");
    log(`wrote ${Object.keys(finalEnv).length} keys`);
  } else {
    log("dry-run complete, no files written");
  }

  log("done");
}

main();
